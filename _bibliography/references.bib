@inproceedings{Deme18a,
  author = {Demeyer, Serge and Verhaeghe, Beno{\^\i}t and Etien, Anne and Anquetil, Nicolas and Ducasse, St\'ephane},
  title = {Evaluating the Efficiency of Continuous Testing during Test-Driven Development},
  abstract = {Continuous testing is a novel feature within modern programming environments, where unit tests constantly run in the background providing early feedback about breaking changes. One of the more challenging aspects of such a continuous testing tool is choosing the heuristic which selects the tests to run based on the changes recently applied. To help tool builders select the most appropriate test selection heuristic, we assess their efficiency in a continuous testing context. We observe on two small but representative cases that a continuous testing tool generates significant reductions in number of tests that need to be executed. Nevertheless, these heuristics sometimes result in false negatives, thus in rare occasions discard pertinent tests.},
  booktitle = {Proceedings {VST 2018} (2nd IEEE International Workshop on Validation, Analysis and Evolution of Software Tests)},
  pages = {1 -- 5},
  year = {2018},
  url = {https://hal.inria.fr/hal-01717343},
  pdf = {https://hal.inria.fr/hal-01717343/document},
  hal-id = {hal-01717343},
  doi = {10.1109/VST.2018.8327152},
  month = mar,
  tagnicolasa = {other test},
  annote = {internationalworkshop}}

@inproceedings{Verh17a,
  author = {Verhaeghe, Beno{\^\i}t and Nicolas Anquetil and St\'ephane Ducasse and Vincent Blondeau},
  title = {Usage of Tests in an Open-Source Community},
  booktitle = {Proceedings of the 12th Edition of the International Workshop on Smalltalk Technologies},
  pages = {4:1--4:9},
  publisher = {ACM},
  year = {2017},
  doi = {10.1145/3139903.3139909},
  annote = {internationalworkshop},
  abstract = {During the development, it is known that tests ensure the good behavior of applications and improve their quality. We studied developers testing behavior inside the Pharo community in the purpose to improve it. In this paper, we take inspiration from a paper of the literature to enhance our comprehension of test habits in our open source community. We report results of a field study on how often the developers use tests in their daily practice, whether they make use of tests selection and why they do. Results are strengthened by interviews with developers involved in the study. The main findings are that developers run tests every modifications of their code they did; most of the time they practice test selection (instead of launching an entire test suite); however they are not accurate in their selection; they change their selection depending on the duration of the tests and; contrary to expectation, test selection is not influenced by the size of the test suite.},
  series = {IWST '17},
  isbn = {978-1-4503-5554-4},
  location = {Maribor, Slovenia},
  articleno = {4},
  numpages = {9},
  address = {New York, NY, USA},
  keywords = {lse-pub ; Regression Test Selection ; Case study ; Inter- views ; Pharo Community kzChecking},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Verh17a-IWST-TestUsage.pdf},
  url = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Verh17a-IWST-TestUsage.pdf},
  tagnicolasa = {other test},
  hal-id = {hal-01579106}}

@inproceedings{Verh19a,
  author = {Verhaeghe, Beno{\^\i}t and Etien, Anne and Anquetil, Nicolas and Seriai, Abderrahmane and Deruelle, Laurent and Ducasse, St\'ephane and Derras, Mustapha},
  title = {{GUI} Migration using {MDE} from {GWT} to {Angular} 6: An Industrial Case},
  booktitle = {2019 IEEE 26th International Conference on Software Analysis, Evolution and Reengineering (SANER)},
  year = {2019},
  url = {https://hal.inria.fr/hal-02019015},
  pdf = {https://hal.archives-ouvertes.fr/hal-02019015/document},
  doi = {10.1109/SANER.2019.8667989},
  annote = {internationalconference},
  hal-id = {hal-02019015},
  abstract = {During the evolution of an application, it happens that developers must change the programming language. In the context of a collaboration with Berger-Levrault, a major IT company, we are working on the migration of a GWT application to Angular. We focus on the GUI aspect of this migration which, even if both frameworks are web Graphical User Interface (GUI) frameworks, is made difficult because they use different programming languages and different organization schema. Such migration is complicated by the fact that the new application must be able to mimic closely the visual aspect of the old one so that the users of the application are not disrupted. We propose an approach in four steps that uses a meta-model to represent the GUI at a high abstraction level. We evaluated this approach on an application comprising 470 Java (GWT) classes representing 56 pages. We are able to model all the web pages of the application and 93% of the widgets they contain, and we successfully migrated 26 out of 39 pages (66%). We give examples of the migrated pages, both successful and not.},
  tagnicolasa = {other migration gui},
  address = {Hangzhou, China}}

@inproceedings{Verh19b,
  author = {Dutriez, Clement and Verhaeghe, Beno{\^i}t and Derras, Mustapha},
  title = {Switching of {GUI} framework: the case from {Spec} to {Spec} 2},
  abstract = {Developers used frameworks to create their User Interface. Those frameworks are developed in a specific version of a language and can be used until the retro-compatibility is broken. In such case, developers need to migrate their software systems to a new GUI framework. We proposed a three-step approach to migrate the front-end of an application. This approach includes an importer, a GUI meta-model and an exporter. We validate our experiment on 6 projects in Pharo. We are able to migrate 5 out of 6 projects that all conserve their widgets organization.},
  booktitle = {Proceedings of the 14th Edition of the International Workshop on Smalltalk Technologies},
  year = {2019},
  url = {https://hal.archives-ouvertes.fr/hal-02297858},
  address = {Cologne, Germany},
  month = aug,
  keywords = {lse-pub ; GUI ; Modernization ; Spec ; Spec 2},
  pdf = {https://hal.archives-ouvertes.fr/hal-02297858/file/iwst19.pdf},
  hal-id = {hal-02297858}}

@inproceedings{Verh19c,
  author = {Verhaeghe, Beno{\^i}t and Etien, Anne and Ducasse, St{\'e}phane and Seriai, Abderrahmane and Deruelle, Laurent and Derras, Mustapha},
  title = {Migration de {GWT} vers {Angular} 6 en utilisant l'{IDM}},
  booktitle = {Conf{\'e}rence en Ing{\'e}nierie du Logiciel},
  year = {2019},
  url = {https://hal.inria.fr/hal-02304296},
  address = {Toulouse, France},
  month = jun,
  pdf = {https://hal.inria.fr/hal-02304296/file/ciel2019.pdf},
  hal-id = {hal-02304296}}

@inproceedings{Verh19d,
  author = {Verhaeghe, Beno{\^i}t and Anquetil, Nicolas and Ducasse, St{\'e}phane and Seriai, Abderrahmane and Deruelle, Laurent and Derras, Mustapha},
  title = {Migrating {GWT} to {Angular} 6 using {MDE}},
  abstract = {In the context of a collaboration with Berger-Levrault, a major IT company, we are working on the migration of a GWT application to Angular. We focus on the GUI aspect of this migration which, even if both are web frameworks, is made difficult because they use different programming languages (Java for one, Typescript for the other) and different organization schemas (e.g. different XML files). Moreover, the new application must mimic closely the visual aspect of the old one so that the users of the application are not disturbed. We propose an approach in three steps that uses a meta-model to represent the GUI at a high abstraction level. We evaluated this approach on an application comprising 470 Java (GWT) classes representing 56 screens. We are able to model all the web pages of the application and 93% of the widgets they contain, and we successfully migrated (i.e., the result is visually equal to the original) 26 out of 39 pages (66%). We give examples of the migrated pages, both successful and not.},
  booktitle = {12th Seminar on Advanced Techniques \& Tools for Software Evolution},
  year = {2019},
  url = {https://hal.inria.fr/hal-02304301},
  address = {Bolzano, Italy},
  month = jul,
  tagnicolasa = {other migration gui},
  pdf = {https://hal.inria.fr/hal-02304301/file/sattose2019.pdf},
  hal-id = {hal-02304301}}

@inproceedings{Verh19e,
  author = {Verhaeghe, Beno{\^i}t and Fuhrman, Christopher and Guerrouj, Latifa and Anquetil, Nicolas and Ducasse, St{\'e}phane},
  title = {Empirical Study of Programming to an Interface},
  abstract = {A popular recommendation to programmers in object-oriented software is to "program to an interface, not an implementation" (PTI). Expected benefits include increased simplicity from abstraction, decreased dependency on implementations, and higher flexibility. Yet, interfaces must be immutable, excessive class hierarchies can be a form of complexity, and "speculative generality" is a known code smell. To advance the empirical knowledge of PTI, we conducted an empirical investigation that involves 126 Java projects on GitHub, aiming to measuring the decreased dependency benefits (in terms of cochange).},
  booktitle = {Proceedings of 34th Conference on Automated Software Engineering (ASE'19)},
  year = {2019},
  url = {https://hal.inria.fr/hal-02353681},
  address = {San Diego, United States},
  month = nov,
  tagnicolasa = {other quality},
  annote = {internationalworkshop},
  doi = {10.1109/ASE.2019.00083},
  pdf = {https://hal.inria.fr/hal-02353681/document},
  hal-id = {hal-02304301}}

@inproceedings{Brag20b,
  author = {Santiago Bragagnolo and Beno{\^\i}t Verhaeghe and Abderrahmane Seriai and Mustapha Derras and Anne Etien},
  title = {Challenges for Layout Validation: Lessons Learned},
  booktitle = {International Conference on the Quality of Information and Communications Technology, QUATIC'2020},
  abstract = {Companies are migrating their software systems. The migration process contemplates many steps, UI migration is one of them. To validate the UI migration, most existing approaches rely on visual structure (DOM) comparison. However, in previous work, we experimented such validation and reported that it is not sufficient to ensure a result that is equivalent or even identical to the visual structure of the interface to be migrated. Indeed, two similar DOM may be rendered completely differently. So, we decide to focus on the layout migration validation. We propose a first visual comparison approach for migrated layout validation and experiment it on an industrial case. Hence, from this first experiment and already existing studies on image comparison field, we highlight challenges for layout comparison. For each challenge, we propose possible solutions, and we detail the three main features we need to create a good layout validation approach.},
  year = {2020},
  keywords = {kzEvolution},
  annote = {internationalconference},
  month = sep,
  doi = {10.1007/978-3-030-58793-2_9},
  url = {https://hal.inria.fr/hal-02914750},
  pdf = {https://hal.inria.fr/hal-02914750/document},
  hal-id = {hal-02914750}}

@inproceedings{Anqu20a,
  author = {Nicolas Anquetil and Anne Etien and Houekpetodji, Mahugnon Honor\'e and Beno{\^\i}t Verhaeghe and St\'ephane Ducasse and Clotilde Toullec and Fatija Djareddir and J\`erome Sudich and Mustapha Derras},
  title = {Modular Moose:  A new generation of software reengineering platform},
  abstract = {Advanced reverse engineering tools are required to cope with the complexity of software systems and the specific requirements of numerous different tasks (re-architecturing, migration, evolution). Consequently, reverse engineering tools should adapt to a wide range of situations. Yet, because they require a large infrastructure investment, being able to reuse these tools is key. Moose is a reverse engineering environment answering these requirements. While Moose started as a research project 20 years ago, it is also used in industrial projects, exposing itself to all these difficulties. In this paper we present ModMoose, the new version of Moose. ModMoose revolves around a new meta-model, modular and extensible; a new toolset of generic tools (query module, visualization engine, ...); and an open architecture supporting the synchronization and interaction of tools per task. With ModMoose, tool developers can develop specific meta-models by reusing existing elementary concepts, and dedicated reverse engineering tools that can interact with the existing ones},
  booktitle = {International Conference on Software and Systems Reuse, ICSR2020},
  year = {2020},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Anqu20a-ICSR-Moose.pdf},
  hal-id={hal-02972159},
  annote = {internationalconference},
  keywords = {kzEvolution},
  url = {https://arxiv.org/pdf/2011.10975},
  pdf = {https://arxiv.org/pdf/2011.10975},
  doi = {10.1007/978-3-030-64694-3_8},
  month = dec}
