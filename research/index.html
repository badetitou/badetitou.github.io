<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <meta name="description" content="Benoît Verhaeghe's blog">
    

    <link rel="icon" href="/img/logo/logo.png" type="image/x-icon">


    <title>Research - Benoît Verhaeghe</title>

    <link rel="canonical" href="http://badetitou.github.io/research/">

    <!-- <link rel="stylesheet" href="/assets/vendor/fontawesome-free/css/all.min.css"> -->
    
    <script src="https://kit.fontawesome.com/5574707d0b.js" crossorigin="anonymous"></script>
    
    <!-- My CSS -->
    <link rel="stylesheet" href="/assets/main.css">
    <!-- My JS -->
    <script src="/js/my-head.js"></script>

    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <link href='//fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>
    <!--Let browser know website is optimized for mobile-->
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>

    <link type="application/atom+xml" rel="alternate" href="http://badetitou.github.io/feed.xml" title="Benoît Verhaeghe" />

</head>


<body>

    <nav>
    <div class="nav-wrapper">
        <a href="#" onclick="openNav()" class="sidenav-trigger"><i class="material-icons">menu</i></a>
        
        <ul class="left hide-on-med-and-down"> <li>
        <a href="/" style="margin-left: 20px;"> Benoît Verhaeghe</a></li></ul>

        <ul class="right hide-on-med-and-down">
            <li>
                <span style="width: 30px; display: inline-block;">
                    <i id="theme-switch" style="font-size: 20px" class="fa-solid fa-1x"></i>
                </span>
            </li>
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
            <li><a href="/teaching/">Teaching</a></li>
        
        
        
        
        
        
        
        
        
            <li><a href="/post/">Posts</a></li>
        
        
        
        
        
        
        
        
        
            <li><a href="/projects/">Projects</a></li>
        
        
        
            <li><a href="/research/">Research</a></li>
        
        
        
        
        
        </ul>
        
    </div>
</nav>

<ul class="sidenav" id="sidenav">
    <a href="javascript:void(0)" class="closebtn" onclick="closeNav()">&times;</a>
    <li><a href="/">Home</a></li>
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
            <li><a href="/teaching/">Teaching</a></li>
        
    
        
        
    
        
        
    
        
            <li><a href="/post/">Posts</a></li>
        
    
        
        
    
        
        
    
        
            <li><a href="/projects/">Projects</a></li>
        
    
        
            <li><a href="/research/">Research</a></li>
        
    
        
        
    
</ul>

<div id="sidenav-overlay" onclick="closeNav()"></div>

    <!-- Page Header -->
<header class="intro-header" style="background-image: url('/img/contact-bg.jpg')">
    <div class="container">
        <div class="row">
            <div class="col s12">
                <div class="site-heading">
                    <h1>Research</h1>
                    <span class="subheading"></span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Main Content -->
<main class="container">
    <div class="row">
  <div class="col s12 m12">
    
    <h2>Journal Articles</h2>
    <ol class="bibliography"><li><div class="accordion">
  <input type="checkbox" id="darbordmigrating">
  <label class="accordion-header" for="darbordmigrating">
    <div class="bibliography-header">
      <div class="bibliography-title">
        Migrating the Communication Protocol of Client-Server Applications
      </div>
      <div class="bibliography-author">
        
          Gabriel Darbord, 
        
          Benoît Verhaeghe, 
        
          Anne Etien, 
        
          Nicolas Anquetil, 
        
          Mustapha Derras
        
      </div>
      <div class="bibliography-booktitle">
        
        IEEE Software
      </div>
      
        <i>2023</i>
      
      
        <a href="https://hal.science/hal-04050310v1/file/Darb23a.pdf">PDF</a>
      
      
    </div>
  </label>
  <div class="accordion-content">
    As part of a collaboration with Berger-Levrault, an international IT company, we are working on the migration of client-server applications. To escape legacy technologies and to evolve towards a “software as a service” model, the company decided to migrate the client side of its applications to Angular 14 and the server side to Spring Boot. In this paper, we focus on the migration of client-server communication from RMI and GWT-RPC to the REST architectural style. We identify issues associated with such a migration and propose a tool-based approach to address them. The migration involves (1) identifying existing services and exchanged data structures; (2) migrating the services; (3) migrating the data structures on the new client side; and (4) in some cases, reducing the amount of exchanged data to address performance issues. We experimented with our approach on four of the company’s applications currently using RMI or GWT-RPC.
  </div>
</div>
</li>
<li><div class="accordion">
  <input type="checkbox" id="Verh21b">
  <label class="accordion-header" for="Verh21b">
    <div class="bibliography-header">
      <div class="bibliography-title">
        From GWT to Angular: An Experiment Report on Migrating a Legacy Web Application
      </div>
      <div class="bibliography-author">
        
          Benoît Verhaeghe, 
        
          Anas Shatnawi, 
        
          Abderrahmane Seriai, 
        
          Anne Etien, 
        
          Nicolas Anquetil, 
        
          Mustapha Derras, 
        
          Stephane Ducasse
        
      </div>
      <div class="bibliography-booktitle">
        
        IEEE Software
      </div>
      
        <i>2021</i>
      
      
        <a href="https://hal.archives-ouvertes.fr/hal-03313462/document">PDF</a>
      
      
        <a href="https://dx.doi.org/10.1109/MS.2021.3101249" >DOI</a>
      
    </div>
  </label>
  <div class="accordion-content">
    Berger-Levrault is an international company that developed applications in GWT for more than 10 years. However, GWT is no longer actively maintained, with only one major update since 2015. To avoid being stuck with legacy technology, the company decided to migrate its applications to Angular. However, because of the size of the applications (more than 500 web pages per application), rewriting from scratch is not desirable. To ease the migration, we designed a semi-automated migration approach that helps developers migrate applications’ front-end from GWT to Angular and a tool that performs the migration. In this paper, we present our approach and tool. We validated the approach on concrete application migration and compared its benefits to redeveloping the application manually. We report that the semi-automated migration offers an effort reduction over a manual migration. Finally, we present recommendations for future migration projects.
  </div>
</div>
</li>
<li><div class="accordion">
  <input type="checkbox" id="Verh21a">
  <label class="accordion-header" for="Verh21a">
    <div class="bibliography-header">
      <div class="bibliography-title">
        GUI visual aspect migration: a framework agnostic solution
      </div>
      <div class="bibliography-author">
        
          Benoît Verhaeghe, 
        
          Nicolas Anquetil, 
        
          Anne Etien, 
        
          Stéphane Ducasse, 
        
          Abderrahmane Seriai, 
        
          Mustapha Derras
        
      </div>
      <div class="bibliography-booktitle">
        
        Automated Software Engineering
      </div>
      
        <i>2021</i>
      
      
        <a href="https://link.springer.com/epdf/10.1007/s10515-021-00284-z?sharing_token=uGynIsRRHShc3wZEPZ4uife4RwlQNchNByi7wbcMAY44F3gcxajwLgNFZBTTtvt9Ze39TcNJgfzugL2qtVGnYyexnPc5xotuhmYx5CMVHbVkuSHoHz1nFEbK1MUblQUdvNP6YXMLdLAG72djsCTEF9cI40mp7yMaWD2gWhSwNAI%3D">PDF</a>
      
      
        <a href="https://dx.doi.org/10.1007/s10515-021-00284-z" >DOI</a>
      
    </div>
  </label>
  <div class="accordion-content">
    With the generalization of mobile devices and Web applications, GUI frameworks evolve at a fast pace: JavaFX replaced Swing, Angular 8 replaced Angular 1.4 which had replaced Google Web Toolkit (GWT). This situation forces organizations to migrate their applications to modern frameworks regularly so they do not become obsolete. There has been research in the past on automatic GUI migration. However, and concurrently, large organisations’ applications use many different technologies. For example, the IT company with which we are working, Berger-Levrault, wishes to migrate applications written in generic programming language (Java/GWT), proprietary "4th generation" languages (VisualBasic 6, PowerBuilder), or markup languages (Silverlight). Furthermore, one must expect that in a few years time, new frameworks will appear and new migrations will be required. Thus, there is a need for a language-agnostic migration approach allowing one to migrate various legacy GUI to the latest technologies. None of the existing solutions allow to deal with such a variety of GUI framework. They also typically focus on a subpart of the migration (i.e. how to extract a specific GUI framework) ignoring the re-engineering/forward-engineering part of the migration (which is straightforward for a single technology). This makes it difficult to adapt these solutions to other GUI frameworks. We propose an approach to migrate the GUI part of applications. It is based on meta-models to represent the visual element structure and layout. We detail how to create both the GUI extractors and generators, with guidelines to support new markup and programming languages. We evaluate our approach by implementing three extractors and generators for web-based or desktop-based user interfaces defined with generic programming languages (Java, Pharo, TypeScript) or markup languages (XML, HTML). We comment case studies on five applications, opened and closed source, of different sizes. The implementations of our generic approach detect 99% of the widgets and identify (i.e. determine the type of the widget) 97% of them. We give examples of the migrated GUIs, both successful and not.
  </div>
</div>
</li></ol>
    
    <h2>Conference Articles</h2>
    <ol class="bibliography"><li><div class="accordion">
  <input type="checkbox" id="icsoft22">
  <label class="accordion-header" for="icsoft22">
    <div class="bibliography-header">
      <div class="bibliography-title">
        A Hybrid Architecture for the Incremental Migration of a Web Front-end
      </div>
      <div class="bibliography-author">
        
          Benoît Verhaeghe., 
        
          Anas Shatnawi., 
        
          Abderrahmane Seriai., 
        
          Anne Etien., 
        
          Nicolas Anquetil., 
        
          Mustapha Derras., 
        
          Stéphane Ducasse.
        
      </div>
      <div class="bibliography-booktitle">
        Proceedings of the 17th International Conference on Software Technologies - ICSOFT,
        
      </div>
      
        <i>2022</i>
      
      
        <a href="https://hal.archives-ouvertes.fr/hal-03772864/document">PDF</a>
      
      
        <a href="https://dx.doi.org/10.5220/0011338900003266" >DOI</a>
      
    </div>
  </label>
  <div class="accordion-content">
    Nowadays, software migration is an effective solution to adopt new technologies while reusing the business value of existing applications. Among other challenges, the size and complexity of large applications are obstacles that increase the risks of migration projects. Moreover, the migration can imply a switch of programming languages. This is the case when migrating from Java to TypeScript. Thus, it is hard to migrate large and complex applications in one straightforward step. Incremental approaches have been designed to counter this problem. These approaches are based on hybrid architecture usages. However, none of the approaches use a hybrid architecture for GUI defined with different programming languages. In this paper, we propose a new hybrid architecture that enables the incremental migration of web applications. Our architecture is based onWeb Components that allow legacy technology artifacts to work with modern ones. We implement the architecture and use it in the case of migrating GWT applications to Angular. Then, we validate its usability in a real context by migrating an industrial web application.
  </div>
</div>
</li>
<li><div class="accordion">
  <input type="checkbox" id="Verh21c">
  <label class="accordion-header" for="Verh21c">
    <div class="bibliography-header">
      <div class="bibliography-title">
        Migrating GUI behavior: from GWT to Angular
      </div>
      <div class="bibliography-author">
        
          Benoît Verhaeghe, 
        
          Anas Shatnawi, 
        
          Abderrahmane Seriai, 
        
          Nicolas Anquetil, 
        
          Anne Etien, 
        
          Stéphane Ducasse, 
        
          Mustapha Derras
        
      </div>
      <div class="bibliography-booktitle">
        International Conference on Software Maintenance and Evolution
        
      </div>
      
        <i>2021</i>
      
      
        <a href="https://hal.archives-ouvertes.fr/hal-03341866/file/conference_101719.pdf">PDF</a>
      
      
        <a href="https://dx.doi.org/10.1109/ICSME52107.2021.00050" >DOI</a>
      
    </div>
  </label>
  <div class="accordion-content">
    In a collaboration with Berger-Levrault, a major IT company, we are working on the migration of GWT applications to Angular. We focus on the GUI aspect of this migration which requires a framework switch (GWT to Angular) and a programming language switch (Java to TypeScript). Previous work identified that the GUI can be split into the UI structure and the GUI behavioral code. GUI behavioral code is the code executed when the user interacts with the UI. Although the migration of UI structure has already been studied, the migration of the GUI behavioral code has not. To help developers during the migration of their applications, we propose a generic approach in four steps that uses a meta-model to represent the GUI behavioral code. This approach includes a separation of the GUI behavioral code into events (caller code) and the code executed when an event is fired (called code). We present the approach and its implementation for a real industrial case study. The application comprises 470 Java (GWT) classes representing 56 web pages. We give examples of the migrated code. We evaluate the quality of the generated code with standard tools (SonarQube, codelizer) and compare it to another Java to TypeScript converter. The results show that our code has 53% fewer warnings and rule violations for SonarQube, and 99% fewer for codelizer.
  </div>
</div>
</li>
<li><div class="accordion">
  <input type="checkbox" id="Anqu20a">
  <label class="accordion-header" for="Anqu20a">
    <div class="bibliography-header">
      <div class="bibliography-title">
        Modular Moose:  A new generation of software reengineering platform
      </div>
      <div class="bibliography-author">
        
          Nicolas Anquetil, 
        
          Anne Etien, 
        
          Mahugnon Honoré Houekpetodji, 
        
          Benoı̂t Verhaeghe, 
        
          Stéphane Ducasse, 
        
          Clotilde Toullec, 
        
          Fatija Djareddir, 
        
          Jèrome Sudich, 
        
          Mustapha Derras
        
      </div>
      <div class="bibliography-booktitle">
        International Conference on Software and Systems Reuse, ICSR2020
        
      </div>
      
        <i>2020</i>
      
      
        <a href="https://arxiv.org/pdf/2011.10975">PDF</a>
      
      
        <a href="https://dx.doi.org/10.1007/978-3-030-64694-3_8" >DOI</a>
      
    </div>
  </label>
  <div class="accordion-content">
    Advanced reverse engineering tools are required to cope with the complexity of software systems and the specific requirements of numerous different tasks (re-architecturing, migration, evolution). Consequently, reverse engineering tools should adapt to a wide range of situations. Yet, because they require a large infrastructure investment, being able to reuse these tools is key. Moose is a reverse engineering environment answering these requirements. While Moose started as a research project 20 years ago, it is also used in industrial projects, exposing itself to all these difficulties. In this paper we present ModMoose, the new version of Moose. ModMoose revolves around a new meta-model, modular and extensible; a new toolset of generic tools (query module, visualization engine, ...); and an open architecture supporting the synchronization and interaction of tools per task. With ModMoose, tool developers can develop specific meta-models by reusing existing elementary concepts, and dedicated reverse engineering tools that can interact with the existing ones
  </div>
</div>
</li>
<li><div class="accordion">
  <input type="checkbox" id="Brag20b">
  <label class="accordion-header" for="Brag20b">
    <div class="bibliography-header">
      <div class="bibliography-title">
        Challenges for Layout Validation: Lessons Learned
      </div>
      <div class="bibliography-author">
        
          Santiago Bragagnolo, 
        
          Benoı̂t Verhaeghe, 
        
          Abderrahmane Seriai, 
        
          Mustapha Derras, 
        
          Anne Etien
        
      </div>
      <div class="bibliography-booktitle">
        International Conference on the Quality of Information and Communications Technology, QUATIC’2020
        
      </div>
      
        <i>2020</i>
      
      
        <a href="https://hal.inria.fr/hal-02914750/document">PDF</a>
      
      
        <a href="https://dx.doi.org/10.1007/978-3-030-58793-2_9" >DOI</a>
      
    </div>
  </label>
  <div class="accordion-content">
    Companies are migrating their software systems. The migration process contemplates many steps, UI migration is one of them. To validate the UI migration, most existing approaches rely on visual structure (DOM) comparison. However, in previous work, we experimented such validation and reported that it is not sufficient to ensure a result that is equivalent or even identical to the visual structure of the interface to be migrated. Indeed, two similar DOM may be rendered completely differently. So, we decide to focus on the layout migration validation. We propose a first visual comparison approach for migrated layout validation and experiment it on an industrial case. Hence, from this first experiment and already existing studies on image comparison field, we highlight challenges for layout comparison. For each challenge, we propose possible solutions, and we detail the three main features we need to create a good layout validation approach.
  </div>
</div>
</li>
<li><div class="accordion">
  <input type="checkbox" id="Verh19b">
  <label class="accordion-header" for="Verh19b">
    <div class="bibliography-header">
      <div class="bibliography-title">
        Switching of GUI framework: the case from Spec to Spec 2
      </div>
      <div class="bibliography-author">
        
          Clement Dutriez, 
        
          Benoît Verhaeghe, 
        
          Mustapha Derras
        
      </div>
      <div class="bibliography-booktitle">
        Proceedings of the 14th Edition of the International Workshop on Smalltalk Technologies
        
      </div>
      
        <i>2019</i>
      
      
        <a href="https://hal.archives-ouvertes.fr/hal-02297858/file/iwst19.pdf">PDF</a>
      
      
    </div>
  </label>
  <div class="accordion-content">
    Developers used frameworks to create their User Interface. Those frameworks are developed in a specific version of a language and can be used until the retro-compatibility is broken. In such case, developers need to migrate their software systems to a new GUI framework. We proposed a three-step approach to migrate the front-end of an application. This approach includes an importer, a GUI meta-model and an exporter. We validate our experiment on 6 projects in Pharo. We are able to migrate 5 out of 6 projects that all conserve their widgets organization.
  </div>
</div>
</li>
<li><div class="accordion">
  <input type="checkbox" id="Verh19a">
  <label class="accordion-header" for="Verh19a">
    <div class="bibliography-header">
      <div class="bibliography-title">
        GUI Migration using MDE from GWT to Angular 6: An Industrial Case
      </div>
      <div class="bibliography-author">
        
          Benoı̂t Verhaeghe, 
        
          Anne Etien, 
        
          Nicolas Anquetil, 
        
          Abderrahmane Seriai, 
        
          Laurent Deruelle, 
        
          Stéphane Ducasse, 
        
          Mustapha Derras
        
      </div>
      <div class="bibliography-booktitle">
        2019 IEEE 26th International Conference on Software Analysis, Evolution and Reengineering (SANER)
        
      </div>
      
        <i>2019</i>
      
      
        <a href="https://hal.archives-ouvertes.fr/hal-02019015/document">PDF</a>
      
      
        <a href="https://dx.doi.org/10.1109/SANER.2019.8667989" >DOI</a>
      
    </div>
  </label>
  <div class="accordion-content">
    During the evolution of an application, it happens that developers must change the programming language. In the context of a collaboration with Berger-Levrault, a major IT company, we are working on the migration of a GWT application to Angular. We focus on the GUI aspect of this migration which, even if both frameworks are web Graphical User Interface (GUI) frameworks, is made difficult because they use different programming languages and different organization schema. Such migration is complicated by the fact that the new application must be able to mimic closely the visual aspect of the old one so that the users of the application are not disrupted. We propose an approach in four steps that uses a meta-model to represent the GUI at a high abstraction level. We evaluated this approach on an application comprising 470 Java (GWT) classes representing 56 pages. We are able to model all the web pages of the application and 93% of the widgets they contain, and we successfully migrated 26 out of 39 pages (66%). We give examples of the migrated pages, both successful and not.
  </div>
</div>
</li>
<li><div class="accordion">
  <input type="checkbox" id="Verh19e">
  <label class="accordion-header" for="Verh19e">
    <div class="bibliography-header">
      <div class="bibliography-title">
        Empirical Study of Programming to an Interface
      </div>
      <div class="bibliography-author">
        
          Benoît Verhaeghe, 
        
          Christopher Fuhrman, 
        
          Latifa Guerrouj, 
        
          Nicolas Anquetil, 
        
          Stéphane Ducasse
        
      </div>
      <div class="bibliography-booktitle">
        Proceedings of 34th Conference on Automated Software Engineering (ASE’19)
        
      </div>
      
        <i>2019</i>
      
      
        <a href="https://hal.inria.fr/hal-02353681/document">PDF</a>
      
      
        <a href="https://dx.doi.org/10.1109/ASE.2019.00083" >DOI</a>
      
    </div>
  </label>
  <div class="accordion-content">
    A popular recommendation to programmers in object-oriented software is to "program to an interface, not an implementation" (PTI). Expected benefits include increased simplicity from abstraction, decreased dependency on implementations, and higher flexibility. Yet, interfaces must be immutable, excessive class hierarchies can be a form of complexity, and "speculative generality" is a known code smell. To advance the empirical knowledge of PTI, we conducted an empirical investigation that involves 126 Java projects on GitHub, aiming to measuring the decreased dependency benefits (in terms of cochange).
  </div>
</div>
</li>
<li><div class="accordion">
  <input type="checkbox" id="Verh19d">
  <label class="accordion-header" for="Verh19d">
    <div class="bibliography-header">
      <div class="bibliography-title">
        Migrating GWT to Angular 6 using MDE
      </div>
      <div class="bibliography-author">
        
          Benoît Verhaeghe, 
        
          Nicolas Anquetil, 
        
          Stéphane Ducasse, 
        
          Abderrahmane Seriai, 
        
          Laurent Deruelle, 
        
          Mustapha Derras
        
      </div>
      <div class="bibliography-booktitle">
        12th Seminar on Advanced Techniques & Tools for Software Evolution
        
      </div>
      
        <i>2019</i>
      
      
        <a href="https://hal.inria.fr/hal-02304301/file/sattose2019.pdf">PDF</a>
      
      
    </div>
  </label>
  <div class="accordion-content">
    In the context of a collaboration with Berger-Levrault, a major IT company, we are working on the migration of a GWT application to Angular. We focus on the GUI aspect of this migration which, even if both are web frameworks, is made difficult because they use different programming languages (Java for one, Typescript for the other) and different organization schemas (e.g. different XML files). Moreover, the new application must mimic closely the visual aspect of the old one so that the users of the application are not disturbed. We propose an approach in three steps that uses a meta-model to represent the GUI at a high abstraction level. We evaluated this approach on an application comprising 470 Java (GWT) classes representing 56 screens. We are able to model all the web pages of the application and 93% of the widgets they contain, and we successfully migrated (i.e., the result is visually equal to the original) 26 out of 39 pages (66%). We give examples of the migrated pages, both successful and not.
  </div>
</div>
</li>
<li><div class="accordion">
  <input type="checkbox" id="Verh19c">
  <label class="accordion-header" for="Verh19c">
    <div class="bibliography-header">
      <div class="bibliography-title">
        Migration de GWT vers Angular 6 en utilisant l’IDM
      </div>
      <div class="bibliography-author">
        
          Benoît Verhaeghe, 
        
          Anne Etien, 
        
          Stéphane Ducasse, 
        
          Abderrahmane Seriai, 
        
          Laurent Deruelle, 
        
          Mustapha Derras
        
      </div>
      <div class="bibliography-booktitle">
        Conférence en Ingénierie du Logiciel
        
      </div>
      
        <i>2019</i>
      
      
        <a href="https://hal.inria.fr/hal-02304296/file/ciel2019.pdf">PDF</a>
      
      
    </div>
  </label>
  <div class="accordion-content">
    
  </div>
</div>
</li>
<li><div class="accordion">
  <input type="checkbox" id="Deme18a">
  <label class="accordion-header" for="Deme18a">
    <div class="bibliography-header">
      <div class="bibliography-title">
        Evaluating the Efficiency of Continuous Testing during Test-Driven Development
      </div>
      <div class="bibliography-author">
        
          Serge Demeyer, 
        
          Benoı̂t Verhaeghe, 
        
          Anne Etien, 
        
          Nicolas Anquetil, 
        
          Stéphane Ducasse
        
      </div>
      <div class="bibliography-booktitle">
        Proceedings VST 2018 (2nd IEEE International Workshop on Validation, Analysis and Evolution of Software Tests)
        
      </div>
      
        <i>2018</i>
      
      
        <a href="https://hal.inria.fr/hal-01717343/document">PDF</a>
      
      
        <a href="https://dx.doi.org/10.1109/VST.2018.8327152" >DOI</a>
      
    </div>
  </label>
  <div class="accordion-content">
    Continuous testing is a novel feature within modern programming environments, where unit tests constantly run in the background providing early feedback about breaking changes. One of the more challenging aspects of such a continuous testing tool is choosing the heuristic which selects the tests to run based on the changes recently applied. To help tool builders select the most appropriate test selection heuristic, we assess their efficiency in a continuous testing context. We observe on two small but representative cases that a continuous testing tool generates significant reductions in number of tests that need to be executed. Nevertheless, these heuristics sometimes result in false negatives, thus in rare occasions discard pertinent tests.
  </div>
</div>
</li>
<li><div class="accordion">
  <input type="checkbox" id="Verh17a">
  <label class="accordion-header" for="Verh17a">
    <div class="bibliography-header">
      <div class="bibliography-title">
        Usage of Tests in an Open-Source Community
      </div>
      <div class="bibliography-author">
        
          Benoı̂t Verhaeghe, 
        
          Nicolas Anquetil, 
        
          Stéphane Ducasse, 
        
          Vincent Blondeau
        
      </div>
      <div class="bibliography-booktitle">
        Proceedings of the 12th Edition of the International Workshop on Smalltalk Technologies
        
      </div>
      
        <i>2017</i>
      
      
        <a href="http://rmod-files.lille.inria.fr/Team/Texts/Papers/Verh17a-IWST-TestUsage.pdf">PDF</a>
      
      
        <a href="https://dx.doi.org/10.1145/3139903.3139909" >DOI</a>
      
    </div>
  </label>
  <div class="accordion-content">
    During the development, it is known that tests ensure the good behavior of applications and improve their quality. We studied developers testing behavior inside the Pharo community in the purpose to improve it. In this paper, we take inspiration from a paper of the literature to enhance our comprehension of test habits in our open source community. We report results of a field study on how often the developers use tests in their daily practice, whether they make use of tests selection and why they do. Results are strengthened by interviews with developers involved in the study. The main findings are that developers run tests every modifications of their code they did; most of the time they practice test selection (instead of launching an entire test suite); however they are not accurate in their selection; they change their selection depending on the duration of the tests and; contrary to expectation, test selection is not influenced by the size of the test suite.
  </div>
</div>
</li></ol>

    <h2>Ph.D. Thesis</h2>
    <ol class="bibliography"><li><div class="accordion">
  <input type="checkbox" id="verhaeghe:tel-03428543">
  <label class="accordion-header" for="verhaeghe:tel-03428543">
    <div class="bibliography-header">
      <div class="bibliography-title">
        Incremental Approach for Application GUI Migration using Metamodels
      </div>
      <div class="bibliography-author">
        
          Benoît Verhaeghe
        
      </div>
      <div class="bibliography-booktitle">
        
        
      </div>
      
        <i>2021</i>
      
      
        <a href="https://tel.archives-ouvertes.fr/tel-03428543/document">PDF</a>
      
      
    </div>
  </label>
  <div class="accordion-content">
    Developers use GUI frameworks to design the graphical user interface of their applications. It allows them to reuse existing graphical components and build applications in a fast way. However, with the generalization of mobile devices and Web applications, GUI frameworks evolve at a fast pace: JavaFX replaced Java Swing, Angular 8 replaced Angular 1.4 which had replaced GWT (Google Web Toolkit). Moreover, former GUI frameworks are not supported anymore. This situation forces organizations to migrate their applications to modern frameworks regularly to avoid becoming obsolete. To ease the migration of applications, previous research designed automatic approaches dedicated to migration projects. Whereas they provide good results, they are hard to adapt to other contexts than their original one. For instance, at Berger-Levrault, our industrial partner, applications are written in generic programming languages (Java/GWT), proprietary “4th generation” languages (VisualBasic 6, PowerBuilder), or markup languages (Silverlight). Thus, there is a need for a language-agnostic migration approach allowing one to migrate various GUI frameworks to the latest technologies. Moreover, when performing automatic migration with these approaches, part of the migrated application still needs to be manually fixed. This problem is even more important for large applications where this last step can last months. Thus, companies need to migrate their application incrementally to ensure end-user continuous delivery throughout the process. In this thesis, we propose a new incremental migration approach. It aims at allowing the migration of large applications while ensuring end-user delivery. It consists of migrating pages using our automatic GUI migration tool, fixing them, and integrating them in a hybrid application. To create our GUI migration tool, we designed a pivot meta-model composed of several packages representing the visual and the behavioral aspects of any GUI. We detailed multiple implementations of our GUI migration tool that extract and generate GUI using different frameworks. We successfully applied our migration approach to a real industrial application at Berger-Levrault. The migrated application is now in production. We also validated our automatic GUI migration tool on several migration projects, including applications developed with programming and markup languages. The company is currently using our approach for other migration projects.
  </div>
</div>
</li></ol>

  </div>
</div>
</main>


    <!-- Footer -->
<footer class="footer">
    <div class="container">
        <div class="row">
            <div class="col m12">
                <ul class="list-inline text-center">
                    
                    <li>
                        <a href="https://twitter.com/badetitou">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fab fa-twitter fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li>
                        <a rel="me" href="https://piaille.fr/@badetitou">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fab fa-mastodon fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    
                    <li>
                        <a href="https://orcid.org/0000-0002-4588-2698">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fab fa-orcid fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li>
                        <a href="https://github.com/badetitou">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fab fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li>
                        <a href="https://www.linkedin.com/in/benoitverhaeghe">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fab fa-linkedin-in fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li>
                        <a href="mailto:benoit@badetitou.fr">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fas fa-envelope fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                </ul>
                <p class="text-center">Copyright &copy; badetitou 2023
                </p>
            </div>
        </div>
    </div>
</footer>

    <!-- jQuery -->
<script src="/js/jquery.min.js"></script>

<script src="/js/my.js"></script>
<script src="/js/my-sidenav.js"></script>

<script src="/js/lightense.min.js"></script>

<script>

  // Init Lightense
  window.addEventListener("load", function() {
    Lightense("img:not(.no-lightense),.lightense", {
      background: 'rgba(0,0,0,0.05)'
    });
  }, false);

  // Example: Lazy Lightense
  document.addEventListener("DOMContentLoaded", function(e) {
    function createDom(type, cssClass) {
      var div = document.createElement(type);
      div.className = cssClass;
      return div;
    }

    var thumb = document.querySelector(".lightense-lazy");
    var original = new Image();

    // Init wrapper
    var wrap = createDom("div", "lightense-lazy-wrap");
    thumb.parentNode.insertBefore(wrap, thumb);
    wrap.appendChild(thumb);

    // Wrap thumbnail
    var thumbWrap = createDom("div", "lightense-lazy-thumb");
    thumbWrap.appendChild(thumb);
    wrap.appendChild(thumbWrap);

    // Wrap original
    var originalWrap = createDom("div", "lightense-lazy-large");
    original.src = thumb.dataset.original;
    originalWrap.appendChild(original);
    wrap.appendChild(originalWrap);

    // Load original image
    original.addEventListener(
      "load",
      function() {
        wrap.classList.add("on");
      },
      false
    );
  });
</script>


</body>

</html>
