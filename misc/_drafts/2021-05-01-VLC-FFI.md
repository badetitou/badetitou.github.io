---
author: Benoît "badetitou" Verhaeghe
layout: post
title: "Using FFI to control VLC from Pharo"
subtitle: "An introduction to the FFI library"
date:   2021-05-01 12:00:00 +200
categories: Pharo FFI VLC
---
 
VLC est le logiciel le plus connu permettant de lire des fichiers audio et vidéo. Plus que des fichiers, il permet aussi de lire des streams, et donc de lire, par exemple, le stream diffusé par des caméras de sécurité. Nous présentons ici comment utiliser Pharo pour s’interfacer avec la librairie développer pour VLC et donc contrôler VLC depuis Pharo. 

## Let's dream

Lorsque je travaille, j’ai souvent envie d’écouter de la musique. Mais ma musique est stockée à différents endroits: en local sur mon ordinateur portable, sur mon serveur personnel, sur YouTube et sur des comptes premium de musique en ligne. Bien que je puisse passer d’un système à un autre facilement, je rêvais d’un gestionnaire de musique où tout se retrouverait combiner à un seul endroit. Ne nous mentons pas, c’était aussi l’argument parfait pour faire un peu de Pharo.

## Playing song with Pharo

Pharo permet déjà de jouer de la musique directement via un plugin intégré dans la machine virtuelle (VM). Malheureusement ce plugin est vieillissant et ne nous garantit pas de pouvoir jouer les centaines de format de musique qui existent aujourd’hui. Par contre VLC, lui, est capable de lire tous ces formats audio et vidéo. Afin de pouvoir jouer de la musique contrôlée par Pharo, il suffit donc de manipuler VLC. Et c’est ce que va nous permettre de faire uFFI ! En effet, le projet VLC est supporté sur les trois plateformes les plus utilisées (Linux, Windows et OSX) et fournit aussi sur toutes ces plateformes les librairies partagées libvlc et libvlccore. Une librairie partagée a pour objectif d’être utilisée par d’autres programme. Elles définissent une API permettant à un programme d'interagir avec un autre. Et c’est précisément ce que permet de faire uFFI à savoir appeler depuis Pharo les méthodes définies dans une librairie partagée.

## Set-up FFI

Mettre en place FFI n’a jamais été aussi simple. Il n’y a en effet que très peu de pré-requis : installer le projet que l’on veut utiliser (pour moi c’est VLC), s’assurer que les librairies partagées sont dans le PATH du système. Et voilà pour la première étape !
 
Une fois le projet installé, nous passons au développement. Tout d’abord, nous créons une classe qui sert de lien entre Pharo et VLC. Pharo venant avec un framework complet pour mettre en place FFI, il nous suffit de créer une sous-classe de FFILibrary (VLCLibrary) et de lui indiquer le nom des librairies externes en fonction du système que l’on utilise (.so sur Linux, .dll sur Windows et .dylib sur OSX). Nous avons fini la mise en place de FFI !

```st
VLCLibrary>>#unix64LibraryName
    #('/usr/lib/i386-linux-gnu' '/usr/lib32' '/usr/lib') , ((OSEnvironment current at: 'LD_LIBRARY_PATH' ifAbsent: [ '' ]) substrings: ':')
    do: [ :path |
        | libraryPath |
        libraryPath := path asFileReference / 'libvlc.so'.
        libraryPath exists ifTrue: [ ^ libraryPath fullName ] ].
    self error: 'Cannot locate vlc library. Please check if it installed on your system'
```

## Functions mapping

Une fois le mécanisme d’interfaçage entre Pharo et VLC en place,  nous allons maintenant pouvoir mapper les fonctions de VLC. Pour pouvoir utiliser une fonction définie dans la librairie, nous déclarons dans notre classe VLCLibrary les méthodes que nous allons utiliser. Pour connaître les fonctions, deux options s’offrent à nous, utiliser des outils qui vont extraire des librairies les fonctions disponibles ou… utiliser la documentation ! Heureusement pour nous les librairies de VLC sont bien documentées ce qui simplifie grandement le travail. En accédant à la documentation des librairies nous avons accès à la signature des fonctions disponibles. Il nous suffit de copier et coller la signature des fonctions dans Pharo pour pouvoir ensuite les utiliser. Les types primitifs sont compris par Pharo tandis que nous remplacerons les structures astucieusement par void * afin de les manipuler comme des objets opaques.

```st
VLCLibrary>>#createVLCInstance
    ^ self ffiCall: void * libvlc_new()'
```

## A first test

Nous allons maintenant présenter les premières méthodes que nous avons dû implémenter pour utiliser VLC. Tout d’abord, libvlc_new permet de créer une instance de VLC. Nous allons ensuite utiliser cette instance pour scripter VLC.

![Call to method libvlc_new()](/misc/img/2021-05-01-VLC-FFI/createVLCInstance.png)

Ensuite, nous allons développer le code nécessaire pour jouer une musique hébergée sur notre ordinateur. Pour cela, nous avons besoin de trois méthodes: création d’un média, création du média player correspondant et la méthode play du média player. Les trois méthodes sont décrites dans la documentation par : libvlc_media_new_path, libvlc_media_player_new_from_media et libvlc_media_player_play. Pour leurs implémentations, il suffit de copier les signatures, et de créer des méthodes dans la classe VLCLibrary comme nous l’avons fait pour le new.

```st
VLCLibrary>>#mediaNew: aVLCInstance path: aStringPath
    "Create a media for a certain file path."
    ^ self ffiCall: void * libvlc_media_new_path(void * aVLCInstance, String aStringPath)'
```

```st
VLCLibrary>>#mediaPlayerPlay: aMediaPlayer
    "Play"
    ^ self ffiCall: 'int libvlc_media_player_play(void * aMediaPlayer)'
```

Enfin, quelques lignes dans le playground vont nous permettre de scripter VLC pour jouer une musique.

```st
vlc := VLCLibrary uniqueInstance createVLCInstance.
"do not use accentuated characters for the path"
media := VLCLibrary uniqueInstance mediaNew: vlc path: '/my/file/path.mp3'.
mediaPlayer := VLCLibrary uniqueInstance mediaPlayerNewFromMedia: media.
VLCLibrary uniqueInstance mediaPlayerPlay: mediaPlayer.
```

## Structures mapping - Let's dev in Pharo

En écrivant en Pharo toutes les méthodes publiques des librairies de VLC, il est possible de complètement scripter VLC. Cependant, nous obtenons une seule abstraction avec pleins de méthodes alors qu’il serait nettement préférable de créer des objets qui représentent chacun des aspects de VLC.

Il est ainsi possible d’améliorer notre mappage avec une librairie VLC en effectuant le mappage des structures C vers des objets Pharo. Encore une fois, nous allons pouvoir le faire grâce à VLC. Les structures peuvent être divisées en quatre catégories : les énumérations, les callbacks, les structures C et les structures opaques. FFI offre une solution pour le mappage de chacun d’elles.

Pour les énumérations, nous devons étendre la classe Pharo « FFIExternalEnumeration », ensuite, nous implémentons la méthode « enumDecl » en écrivant un tableau qui contiendra le nom de l’élément de l’énumération suivit de sa valeur, etc. Puis, nous exécutons la méthode « rebuildEnumAccessors » sur la classe, étape va générer les accesseurs à toutes les valeurs de l’énumération. Enfin, nous initialisons la classe. Il est maintenant possible d’utiliser l’énumération en utilisant : nom de l’énumération + nom d’un des éléments de l’énumération.

```st
VLCMediaType class>>#enumDecl
"self rebuildEnumAccessors"
    
    ^ #(libvlc_media_type_unknown 1
libvlc_media_type_file 2
libvlc_media_type_directory 3
libvlc_media_type_disc 4
libvlc_media_type_stream 5
libvlc_media_type_playlist 6)
```

Pour les callbacks, uFFI vient aussi avec une implémentation facile à utiliser. Cette fois ci, nous devons étendre la classe « FFICallback ». Nous allons ensuite définir la signature de fonction à laquelle notre callback correspond en C et le block Pharo qui sera exécuté lorsque le callback sera appelé. Pour la signature de fonction nous définissons deux méthodes : la première « fnSpec » qui retourne la signature de fonction comme nous l’avions fait lors du mappage de l’API, et la seconde « on: » prend un block en paramètre qui sera exécuté lors de l’appel du callback.

![Callback definition](/misc/img/2021-05-01-VLC-FFI/callbackDefinition.png)

C’est pour les structures opaques qu’il est le plus simple de définir un mappage FFI. Il suffit simplement d’étendre la classe Pharo « FFIOpaqueObject ». Cette étape permet ainsi d’utiliser cette structure en ne considérant que ses méthodes. C’est une stratégie employée en C pour cacher le fonctionnement interne de la structure.

Enfin, il reste le cas des structures C. Comme pour les cas précédents, nous étendons cette fois ci la classe « FFIExternalStructure ». Ensuite, nous définissons côté classe la méthode « fieldsDesc » qui retourne un tableau contenant l’ensemble des variables de la structure et leurs types. En exécutant la méthode « rebuildFieldAccessors » sur la classe, nous créons aussi les accesseurs de ces attributs automatiquement.

```st
VLCTrackDescription>>#fieldsDesc
    "self rebuildFieldAccessors"
    ^ #(int i_id;
    String psz_name;
    VLCTrackDescription * p_next;)
```

## C structure mapping

Et voilà ! Nous pouvons maintenant complétement utiliser la librairie VLC comme si c’était une librairie Pharo. Nous allons voir dans la prochaine partie ce que cela nous permet de faire rapidement.
 
## What about the graphical aspect

Nous allons maintenant regarder comment rapidement créer une interface dans Pharo qui va nous permettre de contrôler VLC. Pour ce faire, nous allons utiliser la nouvelle version de Spec avec Pharo 9. L’objectif final est de créer une interface de lecteur audio utilisable pour l’utilisateur. Plus précisément, nous allons ajouter une extension à l’inspecteur de Pharo afin de pourvoir regarder et contrôler l’état de nos player VLC. Pour cela, nous allons faire deux choses : ajouter une extension et créer l’interface utilisateur de l’extension. Pour ajouter une extension il suffit de créer une méthode avec le pragma « inspectorPresentationOrder: title: » qui retourne l’interface que nous voulons créer. Pour définir l’interface utilisateur nous utilisons Spec2 (le framework graphique de référence depuis Pharo 8+). Nous avons défini pour l’interface une progress bar qui nous montre l’avancement d’un morceau de musique et deux boutons « start » et « pause » pour contrôler la lecture. L’exemple complet est disponible sur le repository github de Pharo-LibVLC en chargeant la groupe « inspector » de la baseline.

```st
Metacello new
  baseline: 'VLC';
  repository: 'github://badetitou/Pharo-LibVLC';
  load: 'inspector'
```

Puis il est possible de lancer une musique et d’obtenir l’interface suivante en inspectant :

```st
vlc := VLCLibrary uniqueInstance createVLCInstance.
media := vlc createMediaFromPath: '/path/to/file.mp3'.
mediaPlayer := vlc createMediaPlayerFromMedia: media.
mediaPlayer play
```

## Conclusion

Nous avons vu qu’il est possible de contrôler VLC depuis Pharo. Nous pouvons ainsi lire des morceaux qui proviennent de notre ordinateur, mais aussi depuis d’autres services (comme YouTube) en utilisant la capacités de VLC à jouer un stream audio lu à distance. Nous avons présenté une première interface pour contrôler le player audio de manière graphique. Alors, pourquoi ne pas continuer dans cette direction en créant un media center complet en Pharo, soit sous forme d’application desktop ou bien d’une application web avec le framework Web Seaside (voir l’article sur Seaside dans ce numéro)
